'use strict';

var pixi_js = require('pixi.js');
var EventPropNames = require('../constants/EventPropNames.js');
var compare = require('./compare.js');
var diffProps = require('./diffProps.js');
var isDiffSet = require('./isDiffSet.js');
var isReadOnlyProperty = require('./isReadOnlyProperty.js');
var log = require('./log.js');

"use strict";
const DEFAULT = "__default";
const DEFAULTS_CONTAINERS = /* @__PURE__ */ new Map();
const PIXI_EVENT_PROP_NAME_ERROR_HAS_BEEN_SHOWN = {};
function targetKeyReducer(accumulator, key) {
  if (accumulator) {
    const value = accumulator[key];
    if (!compare.isUndefined(value) && !compare.isNull(value)) {
      return value;
    }
  }
  return accumulator;
}
function applyProps(instance, data) {
  const {
    __pixireact: instanceState = {},
    ...instanceProps
  } = instance;
  let typedData;
  if (isDiffSet.isDiffSet(data)) {
    typedData = data;
  } else {
    typedData = diffProps.diffProps(data, instanceProps);
  }
  const { changes } = typedData;
  let changeIndex = 0;
  while (changeIndex < changes.length) {
    const change = changes[changeIndex];
    let hasError = false;
    let key = change[0];
    let value = change[1];
    const isEvent = change[2];
    const keys = change[3];
    let currentInstance = instance;
    let targetProp = currentInstance[key];
    if (key === "draw" && typeof value === "function") {
      if (instance instanceof pixi_js.Graphics) {
        value(instance);
      } else {
        hasError = true;
        log.log("warn", `The \`draw\` prop was used on a \`${instanceState.type}\` component, but it's only valid on \`graphics\` components.`);
      }
    }
    if (key in EventPropNames.PixiToReactEventPropNames) {
      const typedKey = key;
      hasError = true;
      if (!PIXI_EVENT_PROP_NAME_ERROR_HAS_BEEN_SHOWN[key]) {
        PIXI_EVENT_PROP_NAME_ERROR_HAS_BEEN_SHOWN[key] = true;
        log.log("warn", `Event names must be pascal case; instead of \`${key}\`, you probably want \`${EventPropNames.PixiToReactEventPropNames[typedKey]}\`.`);
      }
    }
    if (!hasError) {
      if (keys.length) {
        targetProp = keys.reduce(targetKeyReducer, currentInstance);
        if (!(targetProp && targetProp.set)) {
          const [name, ...reverseEntries] = keys.reverse();
          currentInstance = reverseEntries.reverse().reduce(targetKeyReducer, currentInstance);
          key = name;
        }
      }
      if (value === `${DEFAULT}remove`) {
        if (currentInstance instanceof pixi_js.Container) {
          let ctor = DEFAULTS_CONTAINERS.get(currentInstance.constructor);
          if (!ctor) {
            ctor = currentInstance.constructor;
            ctor = new ctor();
            DEFAULTS_CONTAINERS.set(currentInstance.constructor, ctor);
          }
          value = ctor[key];
        } else {
          value = 0;
        }
      }
      if (isEvent && instanceState) {
        const typedKey = key;
        const pixiKey = EventPropNames.ReactToPixiEventPropNames[typedKey];
        if (value) {
          currentInstance[pixiKey] = value;
        } else {
          delete currentInstance[pixiKey];
        }
      } else if (!isReadOnlyProperty.isReadOnlyProperty(currentInstance, key)) {
        currentInstance[key] = value;
      }
    }
    changeIndex += 1;
  }
  return instance;
}

exports.applyProps = applyProps;
//# sourceMappingURL=applyProps.js.map
